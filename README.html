<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>DevelopmentInContainers</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-light">
        <h1 id="developmentincontainers">DevelopmentInContainers</h1>
<h2 id="bevezetés">Bevezetés</h2>
<p>A Docker és egyéb virualizációs technológiák az üzemeletésben már jelentősen elterjedtek, viszont a fejlesztésnél még csak sokkal szűkebb körben használtak. Egy egyszerű Ruby on Rails framework alapú projecten keresztül vizsgáljuk meg, hogy milyen szinten lehet hasznosítani a konténereket már a fejlesztés folyamtában. Az alkalmazásnak szüksége van egy Ruby nyelvet támogató környezetre és egy PostgreSQL adadtbázisra. Ezek a gazdagépre nem lesznek telepítve, kizárólag konténereken keresztül lesznek használva. A RubyMine és Visual Studio Code IDE-ket fogjuk beállitani és használni, hogy több szemszögből is áttekitsük a lehetőségeket.</p>
<h2 id="miért-érdemes-ezzel-foglalkozni">Miért érdemes ezzel foglalkozni?</h2>
<ul>
<li>Gyorsan és egyszerűen el lehet kezdeni egy adott alkalmazáson dolgozni, ha Dockerizálva van. Nincs szükség eszközök letöltésére, konfigurálására, a konténerek inditása után már fejleszthetünk is.</li>
<li>A fejlesztés és üzemeltetési környezetek közötti eltérések jelentős problémákat okzozhatnak egy alkamazás életciklusa közben. A konténerek által biztositott egységes környezetek csökkentik eznen problémák valószínűségét.</li>
<li>Több alkalmazás párhuzamos fejlesztése adott eszközök eltérő verzióinak használatával könnyen megoldható, mivel könnyen lehet váltani a konténerek között.</li>
</ul>
<h2 id="konténerek-elkszékszítése">Konténerek elkszékszítése</h2>
<p>A JetBrains csapata elkészitett egy példa projektet, a konténerek elkészítéséhez azt vesszük alapul. Elösször szükségünk van egy konténerre amiben, a Rails keretrendszert tudjuk futtatni. Docker Hub-on nem találtam megfelelő image-et ehez, ezért az alábbi Dockerfile-ban érdemes leirni az image-et:</p>
<pre><code class="language-Dockerfile"><div><span class="hljs-keyword">FROM</span> ruby:<span class="hljs-number">2.6</span>.<span class="hljs-number">3</span>
<span class="hljs-keyword">RUN</span><span class="bash"> curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add -</span>
<span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"deb https://dl.yarnpkg.com/debian/ stable main"</span> | tee /etc/apt/sources.list.d/yarn.list</span>
<span class="hljs-keyword">RUN</span><span class="bash"> apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev nodejs postgresql-client yarn</span>
<span class="hljs-keyword">RUN</span><span class="bash"> mkdir /test_app</span>
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /test_app</span>
<span class="hljs-keyword">COPY</span><span class="bash"> Gemfile /test_app/Gemfile</span>
<span class="hljs-keyword">COPY</span><span class="bash"> Gemfile.lock /test_app/Gemfile.lock</span>
<span class="hljs-keyword">COPY</span><span class="bash"> package.json /test_app/package.json</span>
<span class="hljs-keyword">COPY</span><span class="bash"> yarn.lock /test_app/yarn.lock</span>
<span class="hljs-keyword">RUN</span><span class="bash"> gem install bundler -v <span class="hljs-string">'2.0.2'</span></span>
<span class="hljs-keyword">RUN</span><span class="bash"> bundle install</span>
<span class="hljs-keyword">RUN</span><span class="bash"> yarn install --check-files</span>
<span class="hljs-keyword">COPY</span><span class="bash"> . /test_app</span>

<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span>
</div></code></pre>
<p>A fenti image a Ruby 2.6.3-as verzióját tartalmazza alapból, egy Debian rendszeren. Telepítjük még a Yarn és NodeJS csomagagokat, amik kezelik a projectben lévő JavaScript file-okat. Ezután létrehozzuk a test_app mappát és beállítjuk a konténer munkamappájának. Az ezt követő rész felelős az alkalmazás függőségeit képező Ruby és JavaScript könyvtárak letöltéséért. Az utolsó két sor bemásolja a project mappáját a konténerbe, majd 3000 portot elérhetővé teszi a gazdagépen.</p>
<p>A fenti Dockerfile-t felhasználva már elkészithetjük az alkalmazás hálózatát leiró, docker-compose.yml file-t.</p>
<pre><code class="language-docker"><div>version: <span class="hljs-string">'3'</span>
services:
  db:
    image: postgres
    volumes:
      - ./tmp/db:/var/lib/postgresql/data
    environment:
      POSTGRES_HOST_AUTH_METHOD: trust
    ports:
      - <span class="hljs-string">"5432:5432"</span>
  web:
    build: .
    <span class="hljs-comment"># command: bundle exec rails s -p 3000 -b '0.0.0.0'</span>
    command: tail -f /dev/null
    volumes:
      - .:/test_app
      - /test_app/node_modules
    ports:
      - <span class="hljs-string">"3000:3000"</span>
      <span class="hljs-comment"># Ports required for debugging</span>
      - <span class="hljs-string">"1234:1234"</span>
      - <span class="hljs-string">"26166:26168"</span>
    depends_on:
      - db
</div></code></pre>
<p>A file első részében létrehozzuk a db szolgáltást, ami a postgres image-en alapú konténer lesz. Az adatbázisban tárolt adatok mappáját összekötjük valamelyik a host egyik mappájával, ezzel perzisztensé téve az adatbázis adatait. Az egyszerűség kedvéért jelszót nem állítunk be, ezt környezeti váltózóként tudjuk beállitani. Majd a host 5432-es portját a konténer 5432-es portjával összekötjük.</p>
<p>A második szolgáltatásban fog futni a rails web szerver, ezért ezt web néven hozzuk létrehozni. Két lehetséges parancsot is felvettem. Az első elinditja a szervert. A második csak futó állapotban tartja a konténer, hogy egyéb fejlsztés közben csatlakozni lehessen hozzá.</p>
<p>Az alap Rails project elkészíŧéséhez kommentezzük ki a --- tartalmazó sorok közötti részeket a Dockerfile-ban. Ezek a sorok majd az elkészült alkalmazás függőségeinek telepitéséért lesz felelős. Ezután létre kell hoznunk a konténereket, és a web szolgáltatásban telepítenünk kell a rails könyvtárat és létrehozni egy új alkalamazást, amit a PostgreSQL adatbázist fogja használni. Ha létrejött az alkalamzás, akkor a hozzá tartozó adatbázist is létre kell hozni. Az alábbi parancsok kiadásával tehetjük ezt meg.</p>
<pre><code class="language-sh"><div>docker-compose run web bash
gem install rails 
rails new test_app --database=postgresql
rails db:create
</div></code></pre>
<p>A gazdagépen észrevetjük, hogy a létrehozott file-ok tulajdonosa a root felhasználó. Ez nehezíti a file-ok kezelését. Egy kézenfekvő megoldás a problémára, hogy megváltoztajuk a file-ok tulajdonosát:</p>
<pre><code class="language-sh"><div> sudo chown -R <span class="hljs-variable">$USER</span> .
</div></code></pre>
<p>Ez a megoldás hosszútávon nem ideális, mivel mindig meg kell változtatnuk a file-ok tulajdonosát, amikor a konténerből hozzuk létre őket. A Docker lehetőséget biztosít a felhasználói névtért map-elésére. Ezáltal elérhetjük, hogy a konténeren belüli root felhasználóhoz, a konténeren kívül a saját felhasználón tartozzon. Igy a konténeren belül létrehozott file-oknak is mi leszünka a tulajdonosai. Ennek a beállitásához az alábbi lépéseket kell követni.</p>
<p>Állitsuk be a felhasználó által használható UID-ket. Ehez nézzük meg felhasználónevünket <code>$USER</code> váltózóban ,valamint a UID-t az <code>id -u</code> paranccsal. Az alábbi fáljhoz hozzáadunk egy új bejegyzést, ami tartalmazza a felhasználónevünket(user), a UID-t(1000), és a kiosztható ID-k számát(1), kettősponttal elválasztva.</p>
<pre><code><code><div>#/etc/subuid

user:1000:1
</div></code></code></pre>
<p>Végezzük el a fenti műveletet a GID-kre. Annyi különbséggel, hogy itt a saját csoportunk ID-jét használjuk. Ezt az id -g paranccsal kérhetjük le.</p>
<pre><code><code><div>#/etc/subgid
user:127:1
</div></code></code></pre>
<p>A fenti beállitások elvégzése után, userns-remap tulajdonságot kell beállítani a felhasználónevünkre. Ez megtehetjük kapcsolóként.</p>
<pre><code class="language-cmd"><div>dockerd --userns-remap=user
</div></code></pre>
<p>Vagy daemon.json file-ban.</p>
<pre><code class="language-json"><div>#/etc/docker/daemon.json
{
  <span class="hljs-attr">"userns-remap"</span>: <span class="hljs-string">"user"</span>
}
</div></code></pre>
<p>Ezután már a konténerből létrehozott fájlok tulajdonosa a gazdagépen a saját felhasználónk lesz. Az alábbi paranccsal elindihatjuk a konténereinket.</p>
<pre><code class="language-sh"><div>docker-compose up
</div></code></pre>
<p>A localhost 3000-es portán megtekinthetjük a Rails szerver kezdőoldalát.</p>
<p><img src="file:////home/user/Desktop/rails_development_in_containers/images/start.png" alt="alt text" title="Image"></p>
<h2 id="rubymine-konfigurálás">RubyMine konfigurálás</h2>
<p>Elösször gyorsan áttekintjük, miként állithatjuk be, hogy a RubyMine a konténerünet használja fejlesztés során. Megnyitjuk az IDE-t a projectünk mappájában. A <strong>Settings/Preferences/Languages &amp; Frameworks/Ruby SDK and Gems</strong> oldalra navigálunk. Itt a New remote gombra kattintva felugrik egy dialógus ablak. Ezen beállítjuk a Docker Compose használatát. A lehetséges szolgáltatások közül kiválasztjuk a <strong>web</strong>-et. Az oké gombra kattintás után kiválasztjuk a most létrehozott remote-ot.</p>
<p>Ahoz, hogy el tudjuk indtani  az IDE-ből a webszervert létre kell, hoznunk a megfelelő konfigurációs file-t. Ezt a <strong>Edit configurations</strong>-menupont használatával tehetjük meg. Ezene belül a <strong>template</strong>-ek közül válasszuk ki a <strong>Rails</strong> konfigurációt. Állitsuk át a használt docker-compose parancsot, <strong>docker-compose exec</strong>-re. Ezután már elindítható a webszerver.</p>
<p>A debuggolás használatához még szükségünk lesz 2 gem-re. Ezek felvételéhez elösször írjuk be az alábbi sorokata a Gemfile-ba.</p>
<pre><code class="language-Gemfile"><code><div>#Gemfile

gem 'debase'
gem 'ruby-debug-ide'
</div></code></code></pre>
<p>Az IDE alt+enter lenyomása után felkínálja, hogy újra build-eli az imaget. Használjuk ezt a lehetősége, hogy a gem-ek belekerüljenek az image-be. Esetleg további funkció eléréséhez is szükség lehet további gem-ek telepítésére, ezt a fentihez hasonló módon tehetjük meg.</p>
<h2 id="rubymine-használat">Rubymine használat</h2>
<p>A Rails keretrendszer lehetőséget biztosít generátorok használatára, amik segítségével egy CRUD-ot megvalósító, tesztekkel ellátott weboldalt hozhatunk létre. Ennek használatával fogjuk kipróbálni a fejlesztőkörnyezet funkcióit. Ahhoz, hogy parancsokat tudjunk futtatni a konténerben, elöször csatlakoznunk kell hozzá. Ezt az alábbi parancsal tehetjük meg.</p>
<pre><code class="language-sh"><div>docker-compose <span class="hljs-built_in">exec</span> web bash
</div></code></pre>
<p>Alapvetően a RubyMine terminálja nem kapcsolódik a konténerekhez. Több mód is van, hogy a fejlesztőkörnyezet intergrált terminálját automatikusan hozzákapcsoljuk az általunk választott konténerhez. Például a Services oldalon az attach menüpont használatával vagy a Shell Path átállításával. Az egyszerűség kedvért most manuálisan, a fenti paranccsal csatlakozunk a konténerhez, mivel nem lesz errre gyakran szükség.</p>
<p>Ezután a konténerben navigáljunk el a projectünk mappájába (/test_app) és már, ki is adhatjunk a parancsot, amivel hozzáadunk alapvető funkcionalitásokat az alkalmazásunkhoz.</p>
<pre><code class="language-sh"><div>rails g scaffold ruby_mine name:string points:<span class="hljs-built_in">integer</span>
</div></code></pre>
<p>Ha mindent jól csináltunk, akkor az alábbi sorok jelennek meg a konzolon:</p>
<p><img src="file:////home/user/Desktop/rails_development_in_containers/images/mine_generate.png" alt="alt text" title="Image"></p>
<p>Láthajuk, hogy létrejöttek oldalak (.erb kiterjesztéssel), tesztek, valamint egy kontroller is. Főként ezeket fogjuk használni az IDE tesztelés során. A <strong>zöld háromszög</strong> gomb lenyomásával elindítható a webszerver, ami a <a href="http://localhost:3000/">local</a>-es címen elérhető.</p>
<p><img src="file:////home/user/Desktop/rails_development_in_containers/images/mine_server.png" alt="alt text" title="Image"></p>
<p>Ezután próbáljuk ki a többi fontosabb eszköz működését az IDE-ben. A debug, miután beállitottuk, hogy docker exec-el legyen használva, egyből működik a fő alkalmazásban.</p>
<p><img src="file:////home/user/Desktop/rails_development_in_containers/images/mine_debug.png" alt="alt text" title="Image"></p>
<p>Teszteket is könnyedén futhatunk az IDE GUI-ján keresztül. Ehhez navigáljunk egy testeket tartalmazó file-hoz, mondjuk <strong>test/controllers/ruby_mines_controller_test.rb</strong>, itt a <strong>jobb egérgomb</strong> lenyomásával megjelennek a kontextusfüggő lehetőségek. Ezekközül válasszuk a <strong>Run Minitest:</strong>-lehetőséget. A tesztek futásának eredményét is megjeleníti a fejesztőkörnyezet. Emellet van lehetőség a tesztek közül csak egyet futttani, valmint debug módban is elindíthatjuk a teszteket.</p>
<p><img src="file:////home/user/Desktop/rails_development_in_containers/images/mine_test.png" alt="alt text" title="Image"></p>
<p>A code-completion és az inteligens navigáció is működik, bár ezekhez nem szükséges a nyelvi környezet, az IDE önellóan nyújtja ezeket a szolgáltatásokat. Szinte minden lehetőség elérhető a konténerből, amit a natívan használt verzió támogat, egy kivételével. A nativ ruby-t használó IDE-ben van lehetőség egyes tesztek futtaása után kilistázni a tesztlfedettséget. Valamint az érintett sorokat is szinezi a környezet, annak függvényében, hogy érintette őket az adott futás. Ez lehetőség még konténeres használat során nem eléhető, de a fejlesztők már tudnak a <a href="https://youtrack.jetbrains.com/issue/RUBY-12337">problémáról</a>.</p>
<h2 id="visual-studio-code">Visual Studio Code</h2>
<p>Nyissuk meg a projectet VSCode-ban. Első lépésként a telepitsük a szükséges extension-öket. Ezek az alábbiak:</p>
<ul>
<li>Remote - Containers</li>
<li>Ruby</li>
<li>Ruby Solargraph</li>
</ul>
<p>Miután ezeket telepitettük inditsuk újra az IDE-t és inditsuk el docker-compose up parancs kiadásávala a konténereket. Ezután a bal oldalon lévő Docker logóra kattinva válasszuk ki rails_developmet_in_containers_web konténert, és válasszuk az Attach Visual Studio Code lehetőséget. Ezután telepítsük a konténerbe is a megfelelő gem-eket. Ezt a felhő gombra kattinva egyszerűen megtehetjük. A Solargraph müködéséhez extra beállításokat kell elvégeznünk, a források között található linken ez is megtekintehtő. Már csak egy lépés van, hogy elkezdhessük használi a fejlesztő környezetet. A launch.json fileban vegyük fel a Listen for rdebug-ide, Rails server konfigurációkat. A VSCode által javasolt előre definiált lehetőségek teljesen megfelelők. Ezek után már használhatjuk az okos navigálást, code-completion-t, valamit debugolhatjuk és tesztelhetjük az alkalmazásunk.</p>
<p><img src="file:////home/user/Desktop/rails_development_in_containers/images/vscode_debug.png" alt="alt text" title="Image"></p>
<p><img src="file:////home/user/Desktop/rails_development_in_containers/images/vscode_test.png" alt="alt text" title="Image"></p>
<h2 id="források">Források</h2>
<ul>
<li>rubymine setup: <a href="https://www.jetbrains.com/help/ruby/using-docker-compose-as-a-remote-interpreter.html">https://www.jetbrains.com/help/ruby/using-docker-compose-as-a-remote-interpreter.html</a></li>
<li>alap image: <a href="https://github.com/JetBrains/sample_rails_app">https://github.com/JetBrains/sample_rails_app</a></li>
<li>konténeren belül létrehozott fájlok jogosultsága problémaleírás: <a href="https://jtreminio.com/blog/running-docker-containers-as-current-host-user/">https://jtreminio.com/blog/running-docker-containers-as-current-host-user/</a></li>
<li>megoldás: <a href="https://www.jujens.eu/posts/en/2017/Jul/02/docker-userns-remap/">https://www.jujens.eu/posts/en/2017/Jul/02/docker-userns-remap/</a></li>
<li>docker user namespace dokumentáció: <a href="https://success.docker.com/article/introduction-to-user-namespaces-in-docker-engine">https://success.docker.com/article/introduction-to-user-namespaces-in-docker-engine</a></li>
<li>vscode debug setup: <a href="https://share.atelie.software/using-visual-studio-code-to-debug-a-rails-application-running-inside-a-docker-container-3416918d8cc8">https://share.atelie.software/using-visual-studio-code-to-debug-a-rails-application-running-inside-a-docker-container-3416918d8cc8</a></li>
<li>vscode language server setup: <a href="https://solargraph.org/guides/rails">https://solargraph.org/guides/rails</a></li>
<li>tesztlefedettség vizualizáció issue: <a href="https://youtrack.jetbrains.com/issue/RUBY-12337">1</a></li>
</ul>

    </body>
    </html>